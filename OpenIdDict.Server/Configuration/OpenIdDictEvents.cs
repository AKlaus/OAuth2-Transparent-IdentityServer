using System.Security.Claims;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.AspNetCore.Authentication.OpenIdConnect;
using Microsoft.IdentityModel.Tokens;
using OpenIddict.Abstractions;
using OpenIddict.Server;

namespace AK.IdentityServerSample.IdentityServer.Configuration;

internal static class OpenIdDictEvents
{
	internal static ValueTask ValidateAuthorizationRequest(OpenIddictServerEvents.ValidateAuthorizationRequestContext context)
	{
		if (!string.Equals(context.ClientId, "TestApp", StringComparison.Ordinal))
		{
			context.Reject(
				error: OpenIddictConstants.Errors.InvalidClient,
				description: "The specified 'client_id' doesn't match a registered application.");
			return default;
		}
		if (!string.Equals(context.RedirectUri, "https://localhost:5001/swagger/oauth2-redirect.html", StringComparison.Ordinal))
		{
			context.Reject(
				error: OpenIddictConstants.Errors.InvalidClient,
				description: "The specified 'redirect_uri' is not valid for this client application.");
			return default;
		}
		return default;
	}
	
	internal static ValueTask ValidateTokenRequest(OpenIddictServerEvents.ValidateTokenRequestContext context)
	{
		if (!string.Equals(context.ClientId, "TestApp", StringComparison.Ordinal))
		{
			context.Reject(
				error: OpenIddictConstants.Errors.InvalidClient,
				description: "The specified 'client_id' doesn't match a registered application.");
			return default;
		}
		// This demo is used by a single public client application.
		// As such, no client secret validation is performed.
		return default;
	}

	internal static async ValueTask HandleAuthorizationRequest(OpenIddictServerEvents.HandleAuthorizationRequestContext context)
	{
		var request = context.Transaction.GetHttpRequest() ??
		              throw new InvalidOperationException("The ASP.NET Core request cannot be retrieved.");
		
		// Retrieve the user principal stored in the authentication cookie.
		var authResult = await request.HttpContext.AuthenticateAsync(CookieAuthenticationDefaults.AuthenticationScheme);
		// If the principal cannot be retrieved, this indicates that the user is not logged in.
		if (authResult?.Succeeded != true || authResult?.Principal == null) 
		{
			// Auth challenge is triggered to redirect the user to the provider's authentication end-point 
			var properties = new AuthenticationProperties { Items = { ["LoginProvider"] = "Microsoft" } };
			await request.HttpContext.ChallengeAsync(OpenIdConnectDefaults.AuthenticationScheme, properties);
			context.HandleRequest();
			return;
		}

		var (email, name) = ResolveAzureAdClaims(authResult.Principal);
		
		// Form new claims
		// Mark all the added claims as being allowed to be persisted in the access token,
		// so that the API controllers can retrieve them from the ClaimsPrincipal instance.
		var identity = new ClaimsIdentity(TokenValidationParameters.DefaultAuthenticationType);
		identity.AddClaim(OpenIddictConstants.Claims.Subject, email, OpenIddictConstants.Destinations.AccessToken);
		identity.AddClaim(OpenIddictConstants.Claims.Email, email, OpenIddictConstants.Destinations.AccessToken);
		identity.AddClaim(OpenIddictConstants.Claims.Name, name, OpenIddictConstants.Destinations.AccessToken);

		// Attach the principal to the authorization context, so that an OpenID Connect response
		// with an authorization code can be generated by the OpenIddict server services.
		context.Principal = new ClaimsPrincipal(identity);
	}

	private static (string email, string name) ResolveAzureAdClaims(ClaimsPrincipal claims)
		=> (
			claims.GetClaim(OpenIddictConstants.Claims.PreferredUsername) ?? "",
			claims.GetClaim(OpenIddictConstants.Claims.Name) ?? ""
		);
}